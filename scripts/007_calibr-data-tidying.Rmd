---
title: tidying data
output:
  html_document:
    keep_md: yes
---

```{r setup, include=FALSE}
library(knitr)
# opts_knit$set(root.dir = "../")
opts_chunk$set(include = TRUE)
```

```{r echo = FALSE}
# for text_icon and code_icon
source("../scripts/helper-02_instruction-icons.R")
```



How to use the tutorial 

- `r text_icon` : transcribe the block of text into your script verbatim. Copy and paste is OK. 
- `r code_icon` : insert a new code chunk then transcribe the R code from the box into the chunk.  Copy and paste is OK.  
- Save and Knit after each addition. 

Packages we use in the tutorial have to be installed (just once) before we can access their functions. For example, if you installed the *readr* package earlier, you don't have to install it again. Install these packages for this tutorial: 

- readr 
- tidyr 
- dplyr 
- stringr 

Sometimes when I show you a bit of R code I also show you the output the code produces.  Do not copy the output to your script. Code output is boxed and has two hash tags on every line, for example: 

```{r include = FALSE}
# read the data set as received
library(readr)
data_received <- read_csv('../data/007_wide-data.csv')
```

```{r echo = FALSE}
head(data_received, n = 3L)
```






# introduction  

Our first paragraph establishes the context for the analysis.

`r text_icon` --- Reminder: this text is copied verbatim.

```
# Introduction

Calibration test data for an Omega LCL-005 (0--5 lb) load cell (a force sensor) has been provided by the test lab. The goal of this analysis is to determine the calibration equation and estimate the sensor accuracy. 
```

- In Rmd, the single hash tag `#` denotes a level-1 heading. 

`r text_icon`
<pre><code>The lab sent an image of the test setup. A known weight (lb) is attached to the eye hook and the load cell bridge produces an output signal (mV). 

<code>```</code>{r fig.cap = 'Figure 1. Load cell calibration test setup', dpi = 300}
knitr::include_graphics("../resources/load-cell-setup-786x989px.png")
<code>```</code>
</code></pre>

- The code chunk option `fig.cap` adds a caption;  `dpi` scales the size of the image. (Image width = width_pixels / dpi.)
- The R syntax `knitr::include_graphics()` tells R to run the *include_graphics()* function from the *knitr* package
- *include_graphics()* imports the image you downloaded earlier to your `resources` directory. 
- The file path is in quotes. `../` tells *knitr* to start one directory level up (the project-level directory), down to `resources/`, and then to the file name. (Even though we've assigned the *knitr* root-directory one level up, a quirk of knitr requires us to use this relative path up.)

```{r echo = FALSE, fig.cap = 'Figure 1. Load cell calibration test setup', dpi = 250}
knitr::include_graphics("../resources/load-cell-setup-786x989px.png")
```


# examine the data 

`r text_icon` --- Start a new section.

```
# Examine the data 
```

 `r code_icon` --- Reminder, this R code goes inside a code chunk.
 
```{r}
# read the data set as received
library(readr)
data_received <- read_csv('../data/007_wide-data.csv')
```

- This code chunk reads the data you downloaded and saved in the `data` directory. 

This is a good moment to remind you that you are learning two syntaxes: R Markdown (Rmd) for reporting and R for computing. The single hash tag # is interpreted differently in the two syntaxes: 

- In R, the single hash tag denotes a comment.
- In Rmd, the single hash tag denotes a level-1 heading. 

`r text_icon`  

```
First look at the data structure.
```

`r code_icon` 

```{r}
str(data_received)
```

- *str()* displays the structure of an R object 

`r text_icon` 

```
As expected, *read_csv()* produced a data frame. All columns are numerical except the *test_point* column that shows test condition number and a direction.
```
- Asterisks around a word or phrase are the Rmd syntax for italics.

`r text_icon`  

```
Look at the first few rows of the data set. 
```

`r code_icon` 

```{r results = 'hide'}
head(data_received)
```

- *head()* displays the first few rows of the data set. 


`r text_icon` 

```
The data set has mV readings in several columns, designated *cycle_1*, *cycle_2*, etc. Thus, the data are in wide form and will have to be reshaped to long form for analysis. 

I see some NA values, which is consistent with the calibration test protocol. A summary of the numerical columns might be useful.
```

`r code_icon`  

```{r results = 'hide'}
# summary-stats except column 1
summary(data_received[ , -1])
```

- *summary()* produces a statistical summary of each column in the data frame. 
- In R, square brackets `[]` subset the data frame. Here the subset `[ , -1]` tells R to keep all rows and omit the first column when evaluating the *summary()* function. 
 
`r text_icon`
 
```
For all cycles, the mean, min, and max  readings (mV) are similar. We have NA in the first and last cycles only, as expected.  
```




# reshape the data to long form

`r text_icon` 

```
# Reshape the data to long form

For analysis, the data set should be in long form, with every column a variable and every row an observation. I've selected these variable names: 

- observ (observation number)
- cycle (cycle number)
- test\_pt (test point number and direction)
- input\_lb (applied reference force)
- output\_mV (sensor readings)
```

- To print an underscore in the prose we have to "escape" the character by writing `\_`. 
 

`r text_icon` 

```
In this case, data reshaping is all about gathering the data in the *cycle* columns, so first we determine which of the column names include *cycle*.
```

`r code_icon` 

```{r}
# indices of cycle columns (listing the mV data)
is_a_cycle_col <- grep('cycle', colnames(data_received), ignore.case = TRUE)

# the column indices
is_a_cycle_col
```

- *colnames()* returns the data frame column names.
- *grep()* is a string pattern-matching function. Here, I use it to compare the string 'cycle' to the column names, ignoring case---a preventative measure in case the testing lab happens to send me data in the future with 'Cycle' capitalized. 
- Writing an object name on a line of its own, e.g., `is_a_cycle_col`,  prints the output. For example, this output tells me that columns `r is_a_cycle_col` have "cycle" in their columns names. 


`r code_icon`

```{r}
# look at the the column names at those locations
colnames(data_received)[is_a_cycle_col]
```

- I subset the column names using `[]` 
- The output confirms that I have the columns I want. 


To reshape these columns, I use the *tidyr* package *gather()* function to create two new data columns: 

-  a new column called *cycle* for gathering the existing cycle-column-names  
- a new column called *output_mV* for gathering the mV readings in those columns 

`r code_icon`

```{r results = 'hide'}
library(tidyr)
long_data <- data_received %>%
	gather(cycle, output_mV, is_a_cycle_col) 
```

- The pipe operator `%>%` can be thought of as the adverb "then". Thus, this code chunk could be read as "Assign the `data_received` data frame to a new object named `long_data`, *then* gather the columns designated by `is_a_cycle_col` into two new columns named `cycle` (for the old column names) and `output_mV` (for the old column data)."

`r text_icon`

```
Examine the result. 
```

`r code_icon`

```{r results = 'hide'}
long_data # print it
str(long_data) # structure
summary(long_data) # summary of column stats
```


```{r echo = FALSE}
summary(long_data)
```


`r text_icon`

```
This summary shows that all the NA values are in the mV readings column. These are not actually missing values. They represent superfluous rows, strictly artifacts of how the test lab organized their data table in the first place. We can safely delete these rows. 
```

`r code_icon`

```{r warning = FALSE, message = FALSE, results = 'hide'}
library(dplyr)
long_data <- long_data %>%
	filter(! output_mV %in% NA)
str(long_data)
```

- The *dplyr* package *filter()* function is a row operation that keeps all rows for which its argument is TRUE 
- `%in%` returns a logical vector indicating a match or not between the arguments on either side 
- If we had written `output_mV %in% NA`, R would return TRUE for all NA entries. But we want the reverse, to keep the NOT NA rows. Thus we use the logical NOT `!` in front of the argument `! output_mV %in% NA`, converting logical FALSE to TRUE (and TRUE to FALSE), thereby keeping the meaningful rows and omitting the NA rows. 

`r text_icon`

```
It's a small enough data set, with `r nrow(long_data)` observations in `r ncol(long_data)` columns, that I can print the full set. 
```

`r code_icon`

```{r}
print(long_data)
```

- Your output should look like the outut printed above. 





# add observation numbers


`r text_icon`

```
# add observation numbers

The test points are in the order in which the data were acquired (consistent with the ANSI/ISA standard). So the observation number is the same as the row number. 
```

`r code_icon`

```{r results = 'hide'}
# add a new column
long_data[ , 'observ'] <- 1:nrow(long_data)
head(long_data)
```

- Here, the subset brackets `[ , 'observ']` add a new column 
- *nrow()* returns the number of rows in the data frame
- The `:` operator creates a sequence 





# simplify the cycle number

`r text_icon`

```
# simplify the cycle number

The *cycle* data are strings, *cycle_1*, *cycle_2*, etc. It might be useful to replace these entries with an integer for the cycle number. 

First, I separate the *cycle* column into two parts using the underscore in the data as the separation pattern. 
```

####################################################

`r code_icon`

```{r}
library(stringr)
cycle_column  <- long_data %>%
	select(cycle)
split_columns <- str_split_fixed(cycle_column, n = 2, pattern = '_')
```

- *stringr* is a package for manipulating character strings
- *string_split_fixed()* is a function that splits our `'cycle'` string column into *n* pieces, using the underscore as the pattern to split on

`r text_icon`

```
Investigate the split_columns object.
```


`r code_icon`

```{r results = 'hide'}
class(split_columns)
```

- *class()* returns that the `split_columns` object is an R matrix, so we can subset it using `[]` notation
- we will want to keep the second column with the number




`r text_icon`

```
I keep only the 2nd column (the cycle number), convert it to an integer (it's a character), and assign it as a new column *cycle_no* in the data frame. 
```

`r code_icon`

```{r}
long_data$cycle_no <- as.integer(split_columns[ , 2])
head(long_data)
tail(long_data)
```

`r text_icon`

```
Spot checking with *head()* and *tail()*, I confirm that the new cycle_no column agrees with the original cycle column data. 
```




# final touches

`r text_icon`

```
The last steps in tidying this data set are to delete the original  *cycle* column and reuse the name for the new cycle column, to shorten the *test_point* column name, and to rearrange columns in a logical order. 
```

`r code_icon`

```{r}
tidy_data <- long_data %>%
	select(-cycle) %>%
	rename('cycle' = cycle_no) %>%
	rename('test_pt' = test_point) %>%
	select(observ, cycle, test_pt, input_lb, output_mV)
print(tidy_data)
```


`r text_icon`

```
Write the tidy data to file in the data directory.
```

`r code_icon`

```{r}
write_csv(tidy_data, "../data/01_calibr_data-tidying.csv")
```







<br><br><br>
