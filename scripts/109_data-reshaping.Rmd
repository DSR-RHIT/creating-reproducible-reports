---
title: "data reshaping"
output:
  html_document:
    keep_md: yes
---

```{r setup, include = FALSE}
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(echo = TRUE, results = 'hide', message = FALSE, warning = FALSE)
```

```{r, echo = FALSE}
# my tutorial functions for text_icon and code_icon
source("scripts/helper_02_icons.R")
```

Continue adding text and code to `01_calibr_data-reshaping.Rmd` file. 

Packages used in this tutorial 

- readr
- dplyr 
- tidyr 

How to use this tutorial 

- `r text_icon` *add text*: type the prose verbatim into the Rmd file 
- `r code_icon` *add code*: insert a code chunk then transcribe the R code 
- `r knit_icon` *Knit* after each addition. 

### preparing to reshape the data

```{r, echo = FALSE}
# read the data set as received
library(readr)
data_received <- read_csv('data/007_wide-data.csv')
```

`r text_icon` 

    # Preparing to reshape the data

    For analysis, the data set should be in long form, with every column a variable and every row an observation. 

    In a calibration, an observation is the set of conditions producing a single sensor reading in mV. For this data set, I propose the following variable names (column names) to characterize an observation:

    - observ (observation number)
    - cycle (cycle number)
    - test\_pt (test point number and direction)
    - input\_lb (applied reference force)
    - output\_mV (sensor readings)

Learning R Markdown:

- The "hyphen, space, text" markup in Rmd, e.g., `- observ`, creates an itemized list (bullet list). The list must start as if it were a new paragraph, with a line space between it and adjacent paragraphs.  
- To print an underscore in the Rmd prose we have to "escape" the character by writing `\_`. 

`r text_icon` 

    Each mV reading in a row is a separate observation. To reshape the data, we want to rewrite every mV reading to its own row, and characterize that observation by its particular cycle number (currently recorded in the column heading) and test condition (force and direction). 

    We begin this process by writing code to identify which of the columns include the character string, *cycle*, in their name. 

Of course, the point of having the code *find* the relevant columns instead of just subsetting the columns manually is to support reproducibility. Your data will change: the next set might have more cycles than this one; or a collaborator might change the order of the columns. Part of doing reproducible work is to anticipate reasonable differences between this data set and the next. 

`r code_icon` 

```{r}
# extract the indices of the column names that include "cycle"
all_col_names  <- colnames(data_received)
is_a_cycle_col <- grep('cycle', all_col_names, ignore.case = TRUE)
```

Learning R: 

- *colnames()* returns the data frame column names.
- *grep()* is a string pattern-matching function. Here, I use it to compare the string 'cycle' to the information in  `all_col_names`.
- I ignore case because the testing lab might send me future data with 'Cycle' capitalized. 
- For readable R code, align the assignment operator `<-` of sequential lines of code where feasible.

`r code_icon` 

```{r}
# the column indices
is_a_cycle_col
```

Learning R:

- Writing a variable on a line of its own, e.g., `is_a_cycle_col`, prints its value(s)
- `is_a_cycle_col` is a vector of integers. The number in brackets `[1]` is the index of the first element. 

### check yourself

Confer with a neighbor

1. What are the indices to the cycle columns? 

### reshaping data from wide to long

We're ready to reshape  `data_received` from wide form to long form. Long form is necessary for effective analysis. 

`r text_icon`

    # Reshaping data from wide to long

In this work, the cycle numbers (the original column headings) are  gathered in one new column and the mV readings (the original column  entries) are gathered in another new column. The *gather()* function from the *tidyr* package arranges each cycle and reading side by side in a new observation row. 

The new data frame has as many rows as there are observations in the original table. 

The columns "not gathered" remain, e.g., `r all_col_names[-is_a_cycle_col]`, with their entries copied into the new rows, maintaining the relationships described in the original data set.

`r code_icon`

```{r, results = 'hide'}
library(tidyr)
long_data <- data_received %>%
	gather(cycle, output_mV, is_a_cycle_col) 
```

Learning R:

- This code chunk could be read as, "Assign  `data_received` to a new data frame `long_data`, *then* gather the columns designated by `is_a_cycle_col` into two new columns, `cycle` and `output_mV`."
- the column names are gathered in the new `cycle` column 
- the mV readings are gathered in the new `output_mV`column

`r text_icon`

    Examine the result. 

`r code_icon`

```{r}
long_data # print it
str(long_data) # examine its structure
summary(long_data) # examine the summary statistics of each column
```

### check yourself

Confer with a neighbor.

1. The total number of observations is?
2. The total number of measured variables is? 

`r text_icon`

    This summary shows, first, that I have the columns I expected. 

    Second, all the NA values are in the mV readings column. These are not actually missing values. They represent superfluous rows, strictly artifacts of how the test lab organized their data table in the first place. We can safely delete these rows. 

`r code_icon`

```{r, warning = FALSE, message = FALSE, results = 'hide'}
library(dplyr)
long_data <- long_data %>%
	filter(! output_mV %in% NA)
str(long_data)
```

Learning R:
 
- The *dplyr* package *filter()* function is a row operation that keeps all rows for which its argument is TRUE 
- `%in%` returns a logical vector indicating a match or not between the arguments on either side. Thus we are comparing the contents of the output\_mV column to NA
- The phrase `output_mV %in% NA` would return TRUE for all NA entries. But we want the reverse, to keep the rows that aren't NA. Thus we use the logical NOT (`!`) in front of the argument, i.e.,  `! output_mV %in% NA`
- *filter()* keeps the rows that are TRUE for "not NA" 

`r text_icon`

    It's a small enough data set, with `r nrow(long_data)` observations in `r ncol(long_data)` columns, that I can print the full set. 

`r code_icon`

```{r}
print(long_data)
```

Your output should look like this:

```{r echo = FALSE, results = 'markup'}
print(long_data)
```

### write to file 

`r text_icon`

    Write the long-form data to file in the data directory.

`r code_icon`

```{r}
write_csv(long_data, "data/01_calibr_data-reshaping.csv")
```

Learning R:

 - the first argument in *write_csv()* is the data frame
 - the path shown will save to the `data` directory with the CSV filename shown 

Save and Knit this file. 

### check yourself

Navigate to your data directory. it should look like this:

    data\
      |-- 007_wide-data.csv
      `-- 01_calibr_data-reshaping.csv



---
Back [examine the wide form data](108_examine-wide-data.html)<br>
Next [data tidying](110_data-tidying.html)

