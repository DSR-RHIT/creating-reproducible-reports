---
title: "linear regression"
output:
  html_document:
    keep_md: yes
---

```{r setup, include = FALSE}
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(echo = TRUE, results = 'hide', message = FALSE, warning = FALSE)
```

```{r, echo = FALSE}
# my tutorial functions for text_icon and code_icon
source("scripts/helper_02_icons.R")
options(echo = FALSE) # turns of echo in the console
```

Packages used in this tutorial  

- readr
- dplyr
- tibble

How to use this tutorial 

- `r text_icon` *add text*: type the prose verbatim into the Rmd file 
- `r code_icon` *add code*: insert a code chunk then transcribe the R code 
- `r knit_icon` *Knit* after each addition. 

### open a new Rmd script

We start a new Rmd script to perform the linear regression analysis and save the results to file.  

- Open a new Rmd file, and name it `03_calibr_regression.Rmd`
- Start the new script with the same YAML header as the previous script
- Change the title to `"Load-cell calibration --- linear regression"`
- Inset the same code chunk for the knitr setup 

Knowing the packages we'll be using, we can load them right away, near the top of the file.

`r code_icon`

```{r, message = FALSE}
# load packages
library(readr)
library(dplyr)
```

### perform the linear regression 

`r text_icon`

    # Perform the linear regression 

`r code_icon`

```{r}
# read the tidy data
calibr_data <- read_csv("results/02_calibr_data-tidying.csv")
head(calibr_data)
```

`r text_icon`

    A linear regression relating the mV readings to the input force  produces the results we need to report the calibration equation and the sensor accuracy. 

    - `input_lb` is the independent variable (*x*) 
    - `output_mV` is the dependent variable (*y*) 

Learning Rmd:

- A pair of single back ticks typeset the word like computer code 
- A pair of asterisks typeset the word in italics 

`r text_icon`

    The *lm()* function creates the regression results we need:  

    - slope and intercept of the linear regression
    - the fitted y-values 
    - the residuals 

`r code_icon`

```{r}
# perform the regression
regr_results <- lm(output_mV ~ input_lb, data = calibr_data)
```

Learning R:

- The linear model function has the form `lm(y ~ x, data = data_frame)`, that is, `y` as a function of `x`, where `y` and `x`  are variables (column names) in `data_frame`
- The argument `y ~ x` is called a *formula* in R  
- Learn more by typing `?lm` in your Console

### extract relevant results 

`r text_icon`

    # Extract relevant results 
    
    Look at the attributes of the `lm()` results. 

`r code_icon`

```{r}
attributes(regr_results)
glimpse(regr_results)
```

Learn R:

- `attributes(regr_results)` retrieves meta-data stored with the object `regr_results`
- `regr_results` contains 12 named objects (collected in an R data structure called a *list*.)
- Add `attributes()` to your list of functions used for exploring data, including `str()`, `head()`, and `tail()`. 

`r text_icon`

    The named variables we need from this list are `[1] coefficients`, `[2] residuals`, and `[5] fitted.values`. Examining the structure of these three variables yields

`r code_icon`

```{r}
# Examine the three objects we want
regr_results_subset <- regr_results[c("coefficients", "residuals", "fitted.values")]
str(regr_results_subset)
```

- We subset `regr_results` using `[]` notation and the three named objects of interest.
- We use `str()` to examine the stucture of each of the three objects. 
- Recall `c()` is how we *combine* elements into a vector

### check yourself

Confer with a neighbor.

1. How many elements in the `coefficients` vector?
2. What is the numeric value of the regression intercept? of the slope? 
3. How many elements in the `residuals` vector? Does it make sense? 

In our linear model, `lm()`, the coefficient of the $x^0$ term is labeled *Intercept*; the coefficient of the $x^1$ term is labeled the 
*input_lb* coefficient, i.e., the  coefficient of $x^1$. This is our slope.   (Higher-order polynomial fits will have additional coefficients, of course, for $x^2, x^3$, etc.)

`r text_icon`

    Coefficients has 2 elements; the first is the intercept, the second is the slope. Residuals and fitted values are vectors the same length as the data set, as expected. 
    
    Extract the variables we need: `intercept`, `slope`, `fitted.values`, and `residuals`.

`r code_icon`

```{r}
intercept <- regr_results$coefficients[1]
slope     <- regr_results$coefficients[2]
y_fit     <- regr_results$fitted.values
residuals <- regr_results$residuals
```

Learn R.

- `regr_results` is a list of 12 named objects. 
- A named object can be retrieved from a list using `$` subsetting notation having the form `list_name$object_name`, e.g., `regr_results$residuals`
- `regr_results$coefficients` returns a vector of 2 numbers, subsetted further using `[]` notation 

### determine sensor accuracy

`r text_icon`

    # Determine sensor accuracy
    
    The ANSI/ISA calibration standard defines accuracy as the maximum positive and maximum negative residual. 

`r code_icon`

```{r}
# determine accuracy in mV
max_resid <- max(residuals)
min_resid <- min(residuals)
```

- `max()` and `min()` are R functions that do the obvious

`r text_icon`

    In percentage form, accuracy is a percent of output span. The standard defines output span as the difference between the max and min y-fitted values. 

`r code_icon`

```{r}
output_span <- max(y_fit) - min(y_fit)
acc_plus    <- max_resid / output_span * 100
acc_minus   <- min_resid / output_span * 100
```

R coding practice:

- Place a space before and after math operators, e.g., `+`, `-`, `/`, `*`, etc. for readability

`r text_icon`

    Display the values. 

`r code_icon`

```{r, collapse = TRUE}
acc_plus
acc_minus
```

`r text_icon`

    Reported accuracy is the absolute value of the largest of these two values.   

`r code_icon`

```{r}
accuracy <- max(abs(c(acc_plus, acc_minus)))
```

### check yourself

Confer with a neighbor.

1. What is your sensor accuracy in percent?

### collect results 

`r text_icon`

    # Collect results 
    
    I'd also like to record the input range.

`r code_icon`

```{r}
x <- calibr_data[ , 'input_lb']
input_range <- max(x) - min(x)
```

Learn R.

- We use `[row, col]` notation to subset an object. Here we select all rows (the row position is left blank) and only one column (named `input_lb`). 

`r text_icon`

    And I can collect these results in a data frame.

`r code_icon`

```{r}
# create a data frame for printing a table of results
options(digits = 3)
library(tibble)
calibr_results <- frame_data(
	~item,         ~value,      ~units,
	'input_range', input_range, 'lb',
	'output_span', output_span, 'mV',
	'slope',       slope,       'mV/lb',
	'intercept',   intercept,   'mV',
	'max_resid',   max_resid,   'mV',
	'min_resid',   min_resid,   'mV',
	'accuracy',    accuracy,    '%'
)
calibr_results
```

Learn R.

- `options()` allows me to set the number of decimal places for printing, so if I print to the Console, the values are easy to read. Type `?options` in the Console to read about other options. 
- In this code chunk, I've deliberately placed each row on its own line to make it easy to compose and check. 
- `frame_data` from the new `tibble` package allows us to assemble a new data frame row by row. 
- In the first row, the tilde `~` identifies column names.

### write results to file

`r text_icon`

    # Write results to file
    
    Save the results table to file. 

`r code_icon`

```{r}
write_csv(calibr_results, "results/04_calibr_regression-results.csv")
```

Because this information is likely to appear in a client report, we save it to the `results` directory.  

`r text_icon`

    Add `y-fit` to the tidy data set and save it with `input_lb` and  `output_mV` for graphing later. 

`r code_icon`

```{r}
graph_data <- calibr_data %>%
	mutate(fit_mV = round(y_fit, 2)) %>%
	select(input_lb, output_mV, fit_mV)
```

Learn R.

- This code chunk can be read. "Assign `calibr_data` to `graph_data` *then* add a new column `fit_mV` that is the `y_fit` results rounded to two decimal places, *then* keep only the three columns listed."
- `round()` is a base-R function for rounding. For most cases, I usually use the `plyr::round_any()` function. For more information, type `?plyr::round_any` in the Console. 

### check yourself

Navigate to your results directory. it should look like this:

    results\
      |-- 02_calibr_data-tidying.csv
      |-- 03_calibr_graph.png
      `-- 04_calibr_regression-results.csv

---
Back [calibration graph](111_calibration-graph.html)<br>
Next [client report](113_client-report.html)
