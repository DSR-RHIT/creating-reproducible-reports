---
title: "Load-cell calibration --- linear regression"
author: "Richard Layton"
date: '2016-08-24'
output: html_document
---

```{r, setup, include = FALSE}
library(knitr)
opts_knit$set(root.dir = '../')
opts_chunk$set(echo = TRUE)
```

```{r, message = FALSE}
# load packages
library(readr)
library(dplyr)
```

# Perform the linear regression 

```{r}
# read the tidy data
calibr_data <- read_csv("data/02_calibr_data-tidying.csv")
head(calibr_data)
```

A linear regression relating the mV readings to the input force  produces the results we need to report the calibration equation and the sensor accuracy. 

- `input_lb` is the independent variable (*x*)
- `output_mV` is the dependent variable (*y*)

The *lm()* function creates the regression results we need:  

- slope and intercept of the linear regression
- the fitted y-values 
- the residuals 

```{r}
# perform the regression
regr_results <- lm(output_mV ~ input_lb, data = calibr_data)
```

# Extract relevant results 

Look at the attributes of the `lm()` results. 

```{r}
attributes(regr_results)
```

The named variables we need from this list are `coefficients`, `residuals`, and `fitted.values`. Examining the structure of these three variables yields

```{r}
# Examine the three objects we want
regr_results_subset <- regr_results[c("coefficients", "residuals", "fitted.values")]
str(regr_results_subset)
```

Coefficients has 2 elements; the first is the intercept, the second is the slope. Residuals and fitted values are vectors the same length as the data set, as expected. 

Extract the variables we need: `intercept`, `slope`, `fitted.values`, and `residuals`.  

```{r}
intercept <- regr_results$coefficients[1]
slope     <- regr_results$coefficients[2]
y_fit     <- regr_results$fitted.values
residuals <- regr_results$residuals
```

# Determine sensor accuracy

The ANSI/ISA calibration standard defines accuracy as the maximum positive and maximum negative residual. 

```{r}
# determine accuracy in mV
max_resid <- max(residuals)
min_resid <- min(residuals)
```

In percentage form, accuracy is a percent of output span. The standard defines output span as the difference between the max and min y-fitted values. 

```{r}
output_span <- max(y_fit) - min(y_fit)
acc_plus    <- max_resid  / output_span * 100
acc_minus   <- min_resid / output_span * 100
```

Display the values. 

```{r, collapse = TRUE}
acc_plus
acc_minus
```

Reported accuracy is the absolute value of the largest of these two values.   

```{r}
accuracy <- max(abs(c(acc_plus, acc_minus)))
```

# Collect results 

I'd also like to record the input range.

```{r}
x <- calibr_data[ , 'input_lb']
input_range <- max(x) - min(x)
```

And I can collect these results in a data frame.

```{r}
# create a data frame for printing a table of results
options(digits = 3)
library(tibble)
calibr_results <- frame_data(
	~item,         ~value,      ~units,
	'input_range', input_range, 'lb',
	'output_span', output_span, 'mV',
	'slope',       slope,       'mV/lb',
	'intercept',   intercept,   'mV',
	'max_resid',   max_resid,   'mV',
	'min_resid',   min_resid,   'mV',
	'accuracy',    accuracy,    '%'
)
calibr_results 
```

# Write results to file

Save the results table to file. 

```{r}
write_csv(calibr_results, "results/03_calibr_regression_results-table.csv")
```

Add `y-fit` to the tidy data set and save it with `input_lb` and  `output_mV` for graphing later. 

```{r, message = FALSE}
graph_data <- calibr_data %>%
	mutate(fit_mV = round(y_fit, 2)) %>%
	select(input_lb, output_mV, fit_mV)
write_csv(graph_data, "results/03_calibr_regression_graph-data.csv")
```

